<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[最怕学霸秀恩爱]]></title>
    <url>%2F2018%2F06%2F15%2F%E6%9C%80%E6%80%95%E5%AD%A6%E9%9C%B8%E7%A7%80%E6%81%A9%E7%88%B1%2F</url>
    <content type="text"><![CDATA[俗话说，在学校最难受的三件事是： 看学霸秀成绩 看情侣秀恩爱 看土豪炫富 比这更难受的三件事是： 看学霸秀恩爱 看土豪秀成绩 看情侣炫富 今天就被一对学霸秀了一脸，在此先记下这个仇了…… PS:这张图是某人自己P的，摄影来自对面的我 没错就是这两个人，两个不折不扣的学霸，分别保研了北大和武大，成绩好，颜值高，气质佳，能力强，极具音乐天赋，刚才还跟我说自小担任文艺委员，小学钢琴考了8级，emmm。 在大一上党课的时候认识了姐夫，被他“骗”进联席会后又认识了羽茜姐姐，后来才知道他们两的关系，还知道了他们也是在联席会认识的……虽然作为单身狗，经常被他们两秀一脸，但还是很感谢他们这两年来对我的帮助，不光是联席会材料和党课的工作，还有学习和生活，一直以来都把他们当作学习的榜样。教我理清复杂的入党材料，带我做好党课班长，用”专业课90+一点也不难“、”不拿国奖不带我玩“来激励我学习，晚上请我吃饭还因为吃辣把嗓子吃坏了…… 临近毕业，别无所赠，只有祝福了，希望你们学业顺利，幸福美满，一直恩爱下去。（记得以后带我去北大玩）]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>生活</tag>
        <tag>记仇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 41 缺失的第一个正数]]></title>
    <url>%2F2018%2F06%2F15%2FLeetCode%2041%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例1： 输入：[1,2,0] 输出：3 示例2： 输入：[3,4,-1,1] 输出：2 示例3： 输入：[7,8,9,11,12] 输出：1 说明： 你的算法的时间复杂度应为 O(n)，并且只能使用常数级别的空间。 解题思路假设给定数组的长度是 n ，可分为两种情况进行讨论。 如果数组是从 1开始连续的正整数序列，那么数组的最大值就是n，第一个未出现的正整数就是 n+1 ； 如果数组并非从 1 开始连续的正整数序列，第一个未出现的正整数必然大于0，且小于等于 n 。 针对第二种情况，我们借助桶排序（bucket sort）的思路来对数组进行调整，使其中的部分元素满足第一种情况。 桶排序基本思想 假设待排序的数组A中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组R，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个”桶”。 在排序时，逐个遍历数组A，将数组A的值，作为”桶数组R”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组A[3]=5，则将R[5]的值+1。 对数组进行遍历，如果某个元素在 1~n 之间，就将其放到原数组中的i-1位置。再次对数组进行遍历，找出第一个不满足 nums[i] != i+1 的数，i+1就是要找的第一个未出现的正整数。 代码实现12345678910111213141516171819public int firstMissingPositive(int[] nums) &#123; int max = nums.length ; if(max == 0) &#123; return 1 ; &#125; for(int i = 0 ; i &lt; max ; i++) &#123; while(nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= max &amp;&amp; nums[nums[i]-1] != nums[i]) &#123; int temp = nums[i] ; nums[i] = nums[temp - 1] ; nums[temp - 1] = temp ; &#125; &#125; for(int i = 0 ; i &lt; max ; i++) &#123; if(nums[i] != i + 1) &#123; return i + 1 ; &#125; &#125; return max + 1 ;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最小正整数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题]]></title>
    <url>%2F2018%2F06%2F15%2FnQueen%2F</url>
    <content type="text"><![CDATA[算法问题描述 八皇后问题是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解. 转换成算法问题可以表述为： 在一个N*N的棋盘上，一共需要放置N枚棋子 要求每一行，每一列上只能放置1枚棋子 要求任意斜线上也只能有1枚棋子 回溯算法的主要思想 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。 但当探索到某一步时，发现原先选择并不优或达不到目标， 就退回一步重新选择，这种走不通就退回再走的技术为回溯法， 而满足回溯条件的某个状态的点称为“回溯点”。 主要思想： 按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 回溯算法解N皇后算法描述 这里用一个N*N的矩阵来存储棋盘。注意，此处的N应该大于等于4，2皇后问题和3皇后问题均无解。 算法开始，清空棋盘。当前行设为第1行，当前列设为第1列。 判断当前行，当前列的位置是否可以放置皇后，即该位置所在的行、列和斜线上是否已经有其他皇后存在。 如果符合放置条件，在当前位置放置1个皇后，当前行设为下一行，当前列设为第一列；如果不符合放置条件，当前列设为下一列，重复第2步。 如果某一行遍历结束后（当前列等于），没有到符合条件的位置放置皇后，那么进行回溯：当前行设为上一行，当前列设为上一行皇后所在位置的下一列，取走该行的皇后。注意，如果回溯到了第1行，算法结束。 如果最后一行找到了皇后位置，就代表有一个问题的可行解，将其输出。然后，当前列设为下一列，取走这一行的皇后，继续执行算法。 代码描述（Java） 实现该算法时，面临的第一个问题就是如何判断当前位置(x,y)是否可以放置皇后。最容易想到的方法是将棋盘存为一个二维矩阵，然后判断X行和Y列上是否已有皇后存在，再判断同一斜线上是否存在其他皇后。用该方法可以实现，代码也不复杂，但效率比较低下。N皇后问题中，需要多次调用这个方法，因此，在设计算法的过程中，要尽可能的对其进行优化。 在这里介绍另外一种方法:把棋盘存储为一个N维数组a[N]，数组中第i个元素的值代表第i行的皇后位置，这样便可以把问题的空间规模压缩为一维O(N)，在判断是否冲突时也很简单，首先每行只有一个皇后，且在数组中只占据一个元素的位置，行冲突就不存在了，其次是列冲突，判断一下是否有a[i]与当前要放置皇后的列j相等即可。通过观察可以发现所有在斜线上冲突的皇后的位置都有规律，即它们所在的行列互减的绝对值相等，即| row – i | = | col – a[i] | 。这样当前位置是否可以放置皇后的问题已经解决。 接下来，将算法分成若干个过程，一步步进行代码实现。 对棋盘进行初始化12345private static void init(int a[])&#123; for (int i = 0 ; i &lt; a.length ; i++) &#123; a[i] = INITIAL ; &#125;&#125; 对一维数组进行遍历，将所有位置都置为同一个初始值。 判断当前位是否可以放置皇后123456789private static boolean valid(int a[],int row,int col) &#123; for(int i = 0 ; i &lt; a.length ; i++) &#123; //列是否相等，行列差是否相等 if (col == a[i] || Math.abs(row - i) == Math.abs(col - a[i])) &#123; return false ; &#125; &#125; return true ;&#125; 只需要判断列冲突和斜线冲突的情况，注意斜线判断的时候是对绝对值的比较。 存储一个可行解123456private static void printqueen(int a[]) &#123; for(int i:a) &#123; System.out.print(i+1+" "); &#125; System.out.println();&#125; 简单的数组打印，不需要多说。加1是为了个人习惯，阅读比较方便。 寻找可行解的过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static int queen(int i) &#123; if(i &lt; 4 || i &gt; 64) &#123; return 0 ; &#125; int a[] = new int[i] ; init(a) ; //初始化 int x = 0 ; //行 int y = 0 ; //列 while(x &lt; i) &#123; //遍历该行所有列，找出皇后的位置 while(y &lt; i) &#123; if(valid(a,x,y)) &#123; a[x] = y ; y = 0 ; break ; &#125; else&#123; y++ ; &#125; &#125; //如果该行未找到皇后位置 if(a[x] == INITIAL) &#123; //如果已经回溯到了第一行，结束算法 if(x == 0) &#123; break ; &#125; else &#123; x-- ; y = a[x] + 1 ; a[x] = INITIAL ; continue ; &#125; &#125; //如果最后一行找到了皇后，代表一个解 if(x == i - 1) &#123; //输出解 printqueen(a); cout++ ; y = a[x] + 1 ; a[x] = INITIAL ; continue ; &#125; x++ ; &#125; return cout ; //返回可行解个数&#125; 入口参数i代表求解皇后问题，应该不小3。返回值是问题的可行解个数。 首先，对数组进行初始化，定义两个变量X和Y，分别代表行和列。第1个while是对行的遍历，第2个while是寻找当前行皇后的位置。如果当前行没找到，进行回溯，如果当前行是最后一行，输出一个解。当回溯到第一行时，算法结束，返回可行解个数。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.lang.Math ;public class NQueen &#123; private static final int INITIAL = -10000 ; private static int cout = 0 ; //对棋盘进行初始化 private static void init(int a[])&#123; for (int i = 0 ; i &lt; a.length ; i++) &#123; a[i] = INITIAL ; &#125; &#125; //判断当前位置是否可以放置一个皇后 private static boolean valid(int a[],int row,int col) &#123; for(int i = 0 ; i &lt; a.length ; i++) &#123; //列是否相等，行列差是否相等 if (col == a[i] || Math.abs(row - i) == Math.abs(col - a[i])) &#123; return false ; &#125; &#125; return true ; &#125; //存储一个可行解 private static void printqueen(int a[]) &#123; for(int i:a) &#123; System.out.print(i+1+" "); &#125; System.out.println(); &#125; public static int queen(int i) &#123; if(i &lt; 4 || i &gt; 64) &#123; return 0 ; &#125; int a[] = new int[i] ; init(a) ; //初始化 int x = 0 ; //行 int y = 0 ; //列 while(x &lt; i) &#123; //遍历该行所有列，找出皇后的位置 while(y &lt; i) &#123; if(valid(a,x,y)) &#123; a[x] = y ; y = 0 ; break ; &#125; else&#123; y++ ; &#125; &#125; //如果该行未找到皇后位置 if(a[x] == INITIAL) &#123; //如果已经回溯到了第一行，结束算法 if(x == 0) &#123; break ; &#125; else &#123; x-- ; y = a[x] + 1 ; a[x] = INITIAL ; continue ; &#125; &#125; //如果最后一行找到了皇后，代表一个解 if(x == i - 1) &#123; //输出解 printqueen(a); cout++ ; y = a[x] + 1 ; a[x] = INITIAL ; continue ; &#125; x++ ; &#125; return cout ; //返回可行解个数 &#125; public static void main(String args[]) &#123; long startTime=System.currentTimeMillis(); //获取开始时间 System.out.println(queen(8)+"个解"); long endTime=System.currentTimeMillis(); //获取结束时间 System.out.println("程序运行时间： "+(endTime-startTime)+"ms"); &#125;&#125; 输出结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293941 5 8 6 3 7 2 4 1 6 8 3 7 4 2 5 1 7 4 6 8 2 5 3 1 7 5 8 2 4 6 3 2 4 6 8 3 1 7 5 2 5 7 1 3 8 6 4 2 5 7 4 1 8 6 3 2 6 1 7 4 8 3 5 2 6 8 3 1 4 7 5 2 7 3 6 8 5 1 4 2 7 5 8 1 4 6 3 2 8 6 1 3 5 7 4 3 1 7 5 8 2 4 6 3 5 2 8 1 7 4 6 3 5 2 8 6 4 7 1 3 5 7 1 4 2 8 6 3 5 8 4 1 7 2 6 3 6 2 5 8 1 7 4 3 6 2 7 1 4 8 5 3 6 2 7 5 1 8 4 3 6 4 1 8 5 7 2 3 6 4 2 8 5 7 1 3 6 8 1 4 7 5 2 3 6 8 1 5 7 2 4 3 6 8 2 4 1 7 5 3 7 2 8 5 1 4 6 3 7 2 8 6 4 1 5 3 8 4 7 1 6 2 5 4 1 5 8 2 7 3 6 4 1 5 8 6 3 7 2 4 2 5 8 6 1 3 7 4 2 7 3 6 8 1 5 4 2 7 3 6 8 5 1 4 2 7 5 1 8 6 3 4 2 8 5 7 1 3 6 4 2 8 6 1 3 5 7 4 6 1 5 2 8 3 7 4 6 8 2 7 1 3 5 4 6 8 3 1 7 5 2 4 7 1 8 5 2 6 3 4 7 3 8 2 5 1 6 4 7 5 2 6 1 3 8 4 7 5 3 1 6 8 2 4 8 1 3 6 2 7 5 4 8 1 5 7 2 6 3 4 8 5 3 1 7 2 6 5 1 4 6 8 2 7 3 5 1 8 4 2 7 3 6 5 1 8 6 3 7 2 4 5 2 4 6 8 3 1 7 5 2 4 7 3 8 6 1 5 2 6 1 7 4 8 3 5 2 8 1 4 7 3 6 5 3 1 6 8 2 4 7 5 3 1 7 2 8 6 4 5 3 8 4 7 1 6 2 5 7 1 3 8 6 4 2 5 7 1 4 2 8 6 3 5 7 2 4 8 1 3 6 5 7 2 6 3 1 4 8 5 7 2 6 3 1 8 4 5 7 4 1 3 8 6 2 5 8 4 1 3 6 2 7 5 8 4 1 7 2 6 3 6 1 5 2 8 3 7 4 6 2 7 1 3 5 8 4 6 2 7 1 4 8 5 3 6 3 1 7 5 8 2 4 6 3 1 8 4 2 7 5 6 3 1 8 5 2 4 7 6 3 5 7 1 4 2 8 6 3 5 8 1 4 2 7 6 3 7 2 4 8 1 5 6 3 7 2 8 5 1 4 6 3 7 4 1 8 2 5 6 4 1 5 8 2 7 3 6 4 2 8 5 7 1 3 6 4 7 1 3 5 2 8 6 4 7 1 8 2 5 3 6 8 2 4 1 7 5 3 7 1 3 8 6 4 2 5 7 2 4 1 8 5 3 6 7 2 6 3 1 4 8 5 7 3 1 6 8 5 2 4 7 3 8 2 5 1 6 4 7 4 2 5 8 1 3 6 7 4 2 8 6 1 3 5 7 5 3 1 6 8 2 4 8 2 4 1 7 5 3 6 8 2 5 3 1 7 4 6 8 3 1 6 2 5 7 4 8 4 1 3 6 2 7 5 92个解程序运行时间： 11ms 递归实现 回溯算法通常可以用递归来实现，其主要代码如下：12345678910111213private void backtrack(int x) &#123; if(x == n)&#123; //如果找到一个解，进行输出 cout++ ; printqueen() ; &#125; else for(int y = 0 ;y &lt; n;y++)&#123; //探测当前行的每一列 a[x] = y ; if(valid(a,x,y)) &#123; backtrack(x+1) ; //递归调用，循环求解 &#125; &#125; &#125; 该方法由于在探测第x行后，如果找到一个可以放置皇后的位置y后，则会递归探测下一行，结束后则会继续探测x行y+1列，故可以找到所有的N皇后的解。 但是一般来说递归的效率比较差，因此此处仅做简单介绍，有兴趣的朋友可自行实现。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯</tag>
        <tag>N皇后</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java synchronized详解]]></title>
    <url>%2F2018%2F06%2F15%2Fsynchronized%2F</url>
    <content type="text"><![CDATA[synchronized 是Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。 当两个并发线程访问同一个对象 object 中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 然而，当一个线程访问 object 的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该 object 中的非 synchronized(this) 同步代码块。 尤其关键的是，当一个线程访问 object 的一个 synchronized(this) 同步代码块时，其他线程对 object 中所有其它 synchronized(this) 同步代码块的访问将被阻塞。 第三个例子同样适用其它同步代码块。也就是说，当一个线程访问 object 的一个 synchronized(this) 同步代码块时，它就获得了这个 object 的对象锁。结果，其它线程对该 object 对象所有同步代码部分的访问都被暂时阻塞。 以上规则对其它对象锁同样适用. ##举例说明.当两个并发线程访问同一个对象 object 中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 123456789101112131415161718package ths;public class Thread1 implements Runnable &#123; public void run() &#123; synchronized(this) &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + " synchronized loop " + i); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread1 t1 = new Thread1(); Thread ta = new Thread(t1, "A"); Thread tb = new Thread(t1, "B"); ta.start(); tb.start(); &#125;&#125; 输出结果： 12345678910A synchronized loop 0 A synchronized loop 1 A synchronized loop 2 A synchronized loop 3 A synchronized loop 4 B synchronized loop 0 B synchronized loop 1 B synchronized loop 2 B synchronized loop 3 B synchronized loop 4 2.当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。 1234567891011121314151617181920212223242526272829303132package ths;public class Thread2 &#123; public void m4t1() &#123; synchronized(this) &#123; int i = 5; while( i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : " + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; &#125; public void m4t2() &#123; int i = 5; while( i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : " + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; public static void main(String[] args) &#123; final Thread2 myt2 = new Thread2(); Thread t1 = new Thread( new Runnable() &#123; public void run() &#123; myt2.m4t1(); &#125; &#125;, "t1" ); Thread t2 = new Thread( new Runnable() &#123; public void run() &#123; myt2.m4t2(); &#125; &#125;, "t2" ); t1.start(); t2.start(); &#125; &#125; 输出结果：12345678910t1 : 4 t2 : 4 t1 : 3 t2 : 3 t1 : 2 t2 : 2 t1 : 1 t2 : 1 t1 : 0 t2 : 0 3.尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。 1234567891011121314//修改Thread2.m4t2()方法：public void m4t2() &#123; synchronized(this) &#123; int i = 5; while( i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : " + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125;&#125; 输出结果： 12345678910t1 : 4 t1 : 3 t1 : 2 t1 : 1 t1 : 0 t2 : 4 t2 : 3 t2 : 2 t2 : 1 t2 : 0 4.第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。 123456789101112//修改Thread2.m4t2()方法如下：public synchronized void m4t2() &#123; int i = 5; while( i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : " + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; 输出结果：12345678910t1 : 4 t1 : 3 t1 : 2 t1 : 1 t1 : 0 t2 : 4 t2 : 3 t2 : 2 t2 : 1 t2 : 0 5.以上规则对其它对象锁同样适用:1234567891011121314151617181920212223242526272829303132333435363738394041package ths;public class Thread3 &#123; class Inner &#123; private void m4t1() &#123; int i = 5; while(i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : Inner.m4t1()=" + i); try &#123; Thread.sleep(500); &#125; catch(InterruptedException ie) &#123; &#125; &#125; &#125; private void m4t2() &#123; int i = 5; while(i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : Inner.m4t2()=" + i); try &#123; Thread.sleep(500); &#125; catch(InterruptedException ie) &#123; &#125; &#125; &#125; &#125; private void m4t1(Inner inner) &#123; synchronized(inner) &#123; //使用对象锁 inner.m4t1(); &#125; private void m4t2(Inner inner) &#123; inner.m4t2(); &#125; public static void main(String[] args) &#123; final Thread3 myt3 = new Thread3(); final Inner inner = myt3.new Inner(); Thread t1 = new Thread( new Runnable() &#123;public void run() &#123; myt3.m4t1(inner);&#125; &#125;, "t1"); Thread t2 = new Thread( new Runnable() &#123;public void run() &#123; myt3.m4t2(inner);&#125; &#125;, "t2"); t1.start(); t2.start(); &#125; &#125; 输出结果： 尽管线程t1获得了对Inner的对象锁，但由于线程t2访问的是同一个Inner中的非同步部分。所以两个线程互不干扰。 12345678910t1 : Inner.m4t1()=4 t2 : Inner.m4t2()=4 t1 : Inner.m4t1()=3 t2 : Inner.m4t2()=3 t1 : Inner.m4t1()=2 t2 : Inner.m4t2()=2 t1 : Inner.m4t1()=1 t2 : Inner.m4t2()=1 t1 : Inner.m4t1()=0 t2 : Inner.m4t2()=0 现在在Inner.m4t2()前面加上synchronized：12345678910private synchronized void m4t2() &#123; int i = 5; while(i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : Inner.m4t2()=" + i); try &#123; Thread.sleep(500); &#125; catch(InterruptedException ie) &#123; &#125; &#125; &#125; 输出结果： 尽管线程t1与t2访问了同一个Inner对象中两个毫不相关的部分,但因为t1先获得了对Inner的对象锁，所以t2对Inner.m4t2()的访问也被阻塞，因为m4t2()是Inner中的一个同步方法。 12345678910t1 : Inner.m4t1()=4 t1 : Inner.m4t1()=3 t1 : Inner.m4t1()=2 t1 : Inner.m4t1()=1 t1 : Inner.m4t1()=0 t2 : Inner.m4t2()=4 t2 : Inner.m4t2()=3 t2 : Inner.m4t2()=2 t2 : Inner.m4t2()=1 t2 : Inner.m4t2()=0]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>synchronized</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯法应用举例——子数组积/和问题]]></title>
    <url>%2F2018%2F06%2F15%2F%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B%E2%80%94%E2%80%94%E5%AD%90%E6%95%B0%E7%BB%84%E7%A7%AF%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[leetcode 713 在 leetcode上面有这样一道题： 给定一个正整数数组 nums。 找出该数组内乘积小于 k 的连续的子数组的个数。 示例1： 输入: nums = [10,5,2,6], k = 100输出: 8解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。需要注意的是 [10,5,2] 并不是乘积小于100的子数组。 该问题的解题思路就是通过对数组的遍历，找出其中连续积小于 k 的区间，每增加一个元素，就说明有该区间的大小的子数组满足条件，若积大于或等于k，则将区间左边的元素去掉，继续执行。其代码如下： 123456789101112public int numSubarrayProductLessThanK(int[] nums, int k) &#123; int cout = 0 ; int left = 0 ; int total = 1 ; for(int right = 0 ; right &lt; nums.length ; right++) &#123; total *= nums[right] ; while(total &gt;= k &amp;&amp; left &lt;= right ) total /= nums[left++] ; cout += right - left + 1 ; &#125; return cout ;&#125; 但是这道题不是今天的主角，做完这道题之后，突然想到，如果子数组是非连续的应该如何求解呢？ 子数组积问题 现在将问题修改为： 给定一个正整数数组 nums。 找出该数组内乘积小于 k 的任意子数组的个数。 解决该问题的主要思路还是和之前的N皇后问题一样，使用回溯算法。 首先定义出问题的单个解。我们可以使用一个一维数组 status[] 来表示单个的解，数组长度和 nums 相同， status[i] 即对应 nums[i] 的状态。在一个解中，单个元素有两种状态，及在解中或者不在解中，因此可以用1和0来表示。 然后我们可以定义问题的解空间。如图所示，用状态空间树来表示解空间就是一棵二叉树，在初始状态下，面临第一次选择，即 statu[0]应该取1还是0，依次类推，从根节点到叶子节点的一条路径就表示问题的一个解。 寻找可行解的过程就是遍历树的过程。在此过程中，我们需要利用一个限界函数，用来剪除掉那些不可能产生可行解的分支。根据题意，我们可以将限界函数定义为：已有元素的积小于 k（也可进一步限定解，剩余的元素必须可以生成可行解，即剩余元素和已有元素的积要大于等于 k ）。 按照深度优先的策略遍历状态空间树，就是回溯的思想，而采用宽度优先的策略则是另一种算法“分支-限界”。 对问题进行分析之后，进行代码实现，在N皇后问题中，使用的是迭代，而此次使用递归来对问题进行求解。 123456789101112131415161718public int backtrack(int[] nums , int status[] , int x , int k ) &#123; status[x] = 1 ; //生成左子树 int total = 1 ; int cout = 0 ; for(int i = 0 ; i &lt;= x ; i++) &#123; if(status[i] != 0) total *= nums[i] ; &#125; if(total &lt; k ) &#123; //是否满足限界函数 cout++ ; if(x &lt; nums.length - 1) cout += backtrack(nums , status , x+1 , k) ; &#125; if(x &lt; nums.length - 1) status[x] = 0 ; //生成右子树 cout += backtrack(nums , status , x+1 , k) ; return cout ;&#125; nums 是给定的数组， status 用来保存每个元素的状态（0或1）， x 用来记录当前结点， k 是给定的积最大值。函数返回一个 cout ，也就是当前子树的可行解个数。 首先令当前结点状态为1，生成左子树，计算已有元素的积，判断是否小于 k ，如果小于则将 cout 加1，对下一个结点进行递归调用，如果不满足则该分支结束遍历。然后令当前结点状态为0，生成右子树，进行递归调用。最后返回 cout 值。 下面是数组初始化和首次调用： 1234567public int numSubarrayProductLessThanK(int[] nums, int k) &#123; int status[] = new int[nums.length] ; for(int i = 0 ; i &lt; status.length ; i++) status[i] = 0 ; int x = 0 ; return backtrack(nums,status,x,k) ;&#125; 子数组和问题 子数组和问题和上面问题相似，要求是找出数组内和等于 k 的任意子数组个数，只需要修改限界函数就可以得到解。 实现代码如下： 123456789101112131415161718192021222324252627public int NumSubarrayProductIsK(int nums[] , int k) &#123; int status[] = new int[nums.length] ; for(int i = 0 ; i &lt; status.length ; i++) &#123; status[i] = 0 ; &#125; int x = 0 ; return backttack_2(nums, status, x, k) ;&#125;public int backttack_2(int nums[] , int statu[] , int x , int k ) &#123; statu[x] = 1 ; //生成左子树 int cout = 0 ; int total = 0 ; for(int i = 0 ; i &lt;= x ; i++) &#123; total += nums[i]*statu[i] ; &#125; if(total == k) &#123; //判断是否满足限界函数 cout++ ; &#125; else if(total &lt; k &amp;&amp; x &lt; nums.length-1) &#123; cout += backttack_2(nums, statu, x+1, k) ; &#125; if(x &lt; nums.length - 1) &#123; statu[x] = 0 ; //生成右子树 cout += backttack_2(nums, statu, x+1, k) ; &#125; return cout ;&#125; 测试代码和输出结果如下： 12345678public class Test &#123; public static void main(String[] args) &#123; Solution s = new Solution() ; int nums[] = new int[]&#123;5,10,6,4,5&#125; ; System.out.println("有"+s.NumSubarrayProductIsK(nums, 10)+"个数组和等于10"); System.out.println("有"+s.numSubarrayProductLessThanK(nums, 10)+"个子数组积小于10"); &#125;&#125; 有3个数组和等于10 有4个子数组积小于10]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯</tag>
        <tag>子数组和</tag>
        <tag>子数组积</tag>
      </tags>
  </entry>
</search>
