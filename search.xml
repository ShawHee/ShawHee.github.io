<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 871 最低加油次数]]></title>
    <url>%2F2018%2F11%2F17%2FLeetCode%20871%20%E6%9C%80%E4%BD%8E%E5%8A%A0%E6%B2%B9%E6%AC%A1%E6%95%B0%20%2F</url>
    <content type="text"><![CDATA[题目描述汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。 沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1] 升汽油。 假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。 当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。 为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。 注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。 示例1 123输入：target = 1, startFuel = 1, stations = []输出：0解释：我们可以在不加油的情况下到达目的地。 示例2 123输入：target = 100, startFuel = 1, stations = [[10,100]]输出：-1解释：我们无法抵达目的地，甚至无法到达第一个加油站。 示例3 12345678输入：target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]输出：2解释：我们出发时有 10 升燃料。我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。我们沿途在1两个加油站停靠，所以返回 2 。 解题思路根据题目要求找到最低加油次数，首先考虑贪心算法。贪心算法的主要思想是：将问题的解决分解为若干个阶段，在当前阶段做出的最优选择，会导致整体最优的结果。 在这道题目中，我们的目标是使得汽车到达终点，其中汽车会经过若干次加油，则可以将每两次加油的中间过程看做一个阶段，加油就是一次选择——选择合适的加油站，使得总的加油次数最少。 接下来，要弄清楚的问题是“当前阶段”有哪些选择，以及最优选择是什么。假如汽车开始的汽油是X升，那么可以行驶X英里，如果从出发点到X公里范围里面一共有Y个加油站，因为要求最低加油次数，所以先假定每次只能加一次油，因此就有Y种选择，最优的选择就是其中具有最大油量的加油站，假定其有max升油，那下一个阶段就变成出发点到X+max英里的位置。（注意已经加油的车站不能再次加油） 如果当前阶段里面无可用的加油站，就说明无法到达目的地；如果任意阶段的选择之后，y+max大于到目的地的距离，就可以到达目的地。 代码实现建立一个数组表示加油站是否已经使用过，初始值为0；y表示当前汽车能够到达的最远点，count记录加油次数，temp记录当前阶段选择的加油站下标。 当y小于target的时候循环选择加油站，对位置处于0~y的加油站进行遍历，找出具有最大油量的加油站，更新y和count的值，并将该加油站的状态置为1。一直循环，直到y大于target或者无可用加油站，即找出的最大油量为0。 完整代码如下： 123456789101112131415161718192021222324252627class Solution &#123; public int minRefuelStops(int target, int startFuel, int[][] stations) &#123; int[] state = new int[stations.length]; // 建立一个数组，0代表未使用，1代表已使用 for (int i = 0; i &lt; state.length; i++) &#123; state[i] = 0; &#125; int y = startFuel; // 代表汽车当前能到达的最远点 int count = 0; // 代表汽车加油的次数 int temp = 0; //记录当前阶段加油站的下标 while (y &lt; target) &#123; int max = 0; // 范围内可获得的最大加油量 for (int i = 0; i &lt; stations.length; i++) &#123; if (stations[i][0] &lt;= y &amp;&amp; state[i] != 1 &amp;&amp; stations[i][1] &gt; max) &#123; max = stations[i][1]; temp = i; &#125; &#125; if(max == 0) &#123; //无可用加油站 return -1; &#125; state[temp] = 1; y = y + max; // 重置到达的最远点 count++; &#125; return count; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序踩坑记录（二)]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一篇文章写的是开发微信小程序的基础性内容，从这一篇开始主要记录我在实际开发过程中一些比较重要的内容，或者某一个问题的具体实现方法。主要根据各个网站、博客、帖子、教程的相关资料，结合自己的开发经验整理而成，内容结构和关联性不强，按点排列，供以后查找使用。本篇为第一部分。 页面跳转页面栈在小程序中，框架以栈的形式维护当前所有的页面，当页面发生变化的时候，页面栈的表现如下。 页面操作 页面栈表现形式 页面初始化 新页面入栈 打开新页面 新页面入栈 页面重定向 当前页面出栈，新页面入栈 页面返回 页面不断出栈，直到目标返回页 Tab切换 页面全部出栈，只留下新的Tab页面 重加载 页面全部出栈，只留下新的页面 获取页面栈getCurrentPages( )函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。 注意： 不能修改页面栈，可能导致程序异常 不能在App.onLaunch的时候调用，此时page还没有生成 常用页面跳转方法通常有两种方式，在JS文件中调用API接口，或者在WXML文件中使用组件&lt;navigator&gt;，也建议使用这种方式进行页面跳转。 打开新页面。wx.navigateTo方法，前一个页面OnHide，新页面onLoad，onShow。 页面重定向。wx.redirectTo方法，前一个页面onUnLoad，新页面onLoad，onShow。 页面返回。wx.navigateBack方法或者按左上角返回按钮，前一个页面onUnload，新页面onShow。 重启动。wx.reLaunch方法，前一个页面onUnload，新页面onLoad,onShow。 Tab切换。wx.switchTab方法或按下方的Tab切换，其生命周期如表所示： 以 A、B 页面为 Tabbar 页面，C 是从 A 页面打开的页面，D 页面是从 C 页面打开的页面为例。 当前页面 路由后页面 触发的生命周期（按顺序） A A Nothing happend A B A.onHide(), B.onLoad(), B.onShow() A B（再次打开） A.onHide(), B.onShow() C A C.onUnload(), A.onShow() C B C.onUnload(), B.onLoad(), B.onShow() D B D.onUnload(), C.onUnload(), B.onLoad(), B.onShow() D（从转发进入） A D.onUnload(), A.onLoad(), A.onShow() D（从转发进入） B D.onUnload(), B.onLoad(), B.onShow() 注意打开一个新页面可用wx.navigateTo和wx.redirectTo方法，区别在于前一个正常入栈，后一个会将页面栈清空；使用前一种方法，在新页面导航栏左边会自动生成一个返回按钮，而后一种方法则不会。 页面渲染条件渲染在标签内使用wx:if进行判断，判断值为true则显示，判断值为false则不显示。 1234&lt;!--wxml--&gt;&lt;view wx:if="&#123;&#123;view1&#125;&#125;"&gt; WEBVIEW &lt;/view&gt;&lt;view wx:elif="&#123;&#123;view2 == 'APP'&#125;&#125;"&gt; APP &lt;/view&gt;&lt;view wx:else="&#123;&#123;3 &gt; 1&#125;&#125;"&gt; MINA &lt;/view&gt; 123456Page(&#123; data: &#123; view1: true view2: 'MINA' &#125;&#125;) 列表渲染使用wx:for控制属性绑定一个数组，从而使用数组中的数据重复渲染该组件。 默认数组的当前项的下标变量名默认为index，数组当前项的变量名默认为item，也可以使用wx:for-index和wx:for-item来指定。 12&lt;!--wxml--&gt;&lt;view wx:for="&#123;&#123;array&#125;&#125;"&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt; 123456789Page(&#123; data: &#123; array: [&#123; message: 'foo', &#125;, &#123; message: 'bar' &#125;] &#125;&#125;) 将wx:for用在&lt;block&gt;标签上，可以渲染一个包含多个组件内容的结构块。例如： 1234&lt;block wx:for="&#123;&#123;[1, 2, 3]&#125;&#125;"&gt; &lt;view&gt; &#123;&#123;index&#125;&#125;: &lt;/view&gt; &lt;view&gt; &#123;&#123;item&#125;&#125; &lt;/view&gt;&lt;/block&gt; wx:key如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如 &lt;input/&gt; 中的输入内容，&lt;switch/&gt; 的选中状态），需要使用 wx:key 来指定列表中项目的唯一的标识符。 wx:key 的值以两种形式提供 字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。 保留关键字 *this 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。 如不提供wx:key，会报一个warning， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。 图片使用使用&lt;image&gt;标签，其默认大小是宽300px、高225px。 属性： src属性，填写图片资源的路径（相对路径）。 binderror属性，发生错误时调用，不常用。 bindload属性，载入完毕时调用，不常用。 mode属性，指定图片裁剪、缩放的模式，其有效值如下。aspectFit最常用。 模式 值 说明 缩放 scaleToFill 不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素 缩放 aspectFit 保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。 缩放 aspectFill 保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。 缩放 widthFix 宽度不变，高度自动变化，保持原图宽高比不变 裁剪 top 不缩放图片，只显示图片的顶部区域 裁剪 bottom 不缩放图片，只显示图片的底部区域 裁剪 center 不缩放图片，只显示图片的中间区域 裁剪 left 不缩放图片，只显示图片的左边区域 裁剪 right 不缩放图片，只显示图片的右边区域 裁剪 top left 不缩放图片，只显示图片的左上边区域 裁剪 top right 不缩放图片，只显示图片的右上边区域 裁剪 bottom left 不缩放图片，只显示图片的左下边区域 裁剪 bottom right 不缩放图片，只显示图片的右下边区域 数据缓存（storage）每个小程序都有自己的本地缓存，可以通过wx.setStorage（wx.setStorageSync）、wx.getStorage（wx.getStorageSync）、wx.clearStorage（wx.clearStorageSync）可以对本地缓存进行设置、获取和清理。同一个微信用户，同一个小程序storage上限为 10MB。localStorage以用户维度隔离，同一台设备上，A 用户无法读取到 B 用户的数据。 注意： 如果用户储存空间不足，小程序会清空最近最久未使用的本地缓存。因此不建议将关键信息全部存在localStorage，以防储存空间不足或用户换设备的情况。 数据存储wx.setStorage(OBJECT)将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，异步接口。 OBJECT参数说明： 参数 类型 必填 说明 key String 是 本地缓存中的指定的 key data Object/String 是 需要存储的内容 success Function 否 接口调用成功的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码： 1234wx.setStorage(&#123; key:"key", data:"value"&#125;) wx.setStorageSync(KEY,DATA)将 data 存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，同步接口。 OBJECT参数说明： 参数 类型 必填 说明 key String 是 本地缓存中的指定的 key data Object/String 是 需要存储的内容 示例代码： 1234try &#123; wx.setStorageSync('key', 'value')&#125; catch (e) &#123; &#125; 数据获取wx.getStorage(OBJECT)从本地缓存中异步获取指定 key 对应的内容。 OBJECT参数说明： 参数 类型 必填 说明 key String 是 本地缓存中的指定的 key success Function 是 接口调用的回调函数,res = {data: key对应的内容} fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） success返回参数说明： 参数 类型 说明 data String key对应的内容 示例代码： 123456wx.getStorage(&#123; key: 'key', success: function(res) &#123; console.log(res.data) &#125; &#125;) wx.getStorageSync(KEY)参数说明： 参数 类型 必填 说明 key String 是 本地缓存中的指定的 key 示例代码： 12345678try &#123; var value = wx.getStorageSync('key') if (value) &#123; // Do something with return value &#125;&#125; catch (e) &#123; // Do something when catch error&#125; wx.getStorageInfo(OBJECT)和wx.getStorageInfoSync用户获取当前缓存信息。包括已存储的keys，当前占用大小和限制空间大小。 数据移除wx.removeStorage(OBJECT)从本地缓存中异步移除指定 key 。 OBJECT参数说明： 参数 类型 必填 说明 key String 是 本地缓存中的指定的 key success Function 是 接口调用的回调函数 fail Function 否 接口调用失败的回调函数 complete Function 否 接口调用结束的回调函数（调用成功、失败都会执行） 示例代码： 123456wx.removeStorage(&#123; key: 'key', success: function(res) &#123; console.log(res.data) &#125; &#125;) wx.removeStorageSync(KEY)从本地缓存中同步移除指定 key 。 参数说明： 参数 类型 必填 说明 key String 是 本地缓存中的指定的 key 示例代码： 12345try &#123; wx.removeStorageSync('key')&#125; catch (e) &#123; // Do something when catch error&#125; 数据清理wx.clearStorage()清理本地数据缓存。 示例代码： 1wx.clearStorage() wx.clearStorageSync()同步清理本地数据缓存 示例代码： 12345try &#123; wx.clearStorageSync()&#125; catch(e) &#123; // Do something when catch error&#125; 页面传值url携带参数前面提到，在页面跳转的时候，会使用到wx.navigateTo或者wx.redirectTo方法，在其中需要指定目标页面的url路径，此时我们可以在url末尾来携带参数，多个参数之间使用&amp;来连接。然后在目标页面的onLoad()函数中获取这些url参数。 12345678910111213// 初始页面A相关代码wx.navigateTo(&#123; var b = 2 url: "/pages/page/page?a=1&amp;b=" + b &#125;) // 目标页面B相关代码Page(&#123; onLoad: function (options) &#123; var a = options.a; // 值：1 var b = options.b; // 值：2 &#125;&#125;) 由于一个页面的onLoad()方法在页面的生命周期中只执行一次，因此这种方法只在目标页面还没有创建的时候，才有效。 使用全局数据存储 将要传递的数据，存储在App对象上。 将要传递的数据，存储在小程序的本地数据缓存（Storage）中。 如，在我们即将进入下一个页面时，可以使用以下方法： 12345678910111213// 1. 存储到app对象上的方式var app = getApp()app.globalData.mydata = &#123;a:1, b:2&#125;; //存储数据到app对象上wx.navigateBack(); //返回上一个页面 // 2.存储到数据缓存的方式wx.setStorage(&#123; key: "mydata", data: &#123;a:1, b:2&#125;, success: function () &#123; wx.navigateBack(); //返回上一个页面 &#125;&#125;) 当打开新页面的时候，就可以通过读取全局存储区域，从而获取到数据。但由于是全局数据，因此在管理上可以会有风险，若一不小心被销毁，就会出现程序错误。 获取页面栈这种方式，是通过调用小程序的API: getCurrentPages()，来获取当前页面路由栈的信息，然后通过原型方法setData对当前对象管理的 data进行修改。如： 1234567//pageA.js...Page(&#123; data: &#123; index: 1 &#125;&#125;) 当跳转到下一个页面B之后，加入在B中有操作需要修改A中的index，则可以使用以下方法： 1234567891011pageB.js...Page(&#123; changeIndexInE: function()&#123; var pages = getCurrentPages(); var prevPage = pages[pages.length - 2]; prevPage.setData(&#123; index: 0 &#125;) &#125;&#125;) 比起全局数据存储的方式，这种方式在逻辑上要清晰得多，也不存在对数据的销毁有额外的管理工作。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序踩坑记录（一）——开发起步]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E8%B5%B7%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[最近在校外做微信小程序开发的实习，从零开始，边学边做。两周之后已经基本实现了小程序的所有页面，趁着比较闲，写写总结，一方面打发时间，一方面方便自己日后查看使用。当然，要是有“有缘人”愿意看一看就更好了。 开发前的准备开发者身份首先需要去微信公众平台申请一个账号，账号分为个人用户和企业用户，需要注意的是个人用户是不能够发布小程序的，只能够写写Demo自己玩。注册登录之后，可以在控制台看到用户身份，在里面可以进行开发协作管理，添加项目成员以及分配权限。 AppID小程序的AppID相当于小程序平台的一个身份证，在开发过程中会经常用到。在微信公众平台的【设置】中，点击【开发设置】，就可以查看到自己的AppID。 开发工具下载前往官方下载平台可以下载开发者工具，自行安装即可。虽说也可以使用其他的编辑器写代码，但就小程序而言，官方的工具拥有比较全面的调试、预览等功能，建议使用。 创建小程序打开小程序开发者工具，使用微信扫码登录开发者工具，进入到小程序项目添加的页面。在项目目录里面选择代码存放的硬盘路径（注意需要使用一个空白文件夹），填入刚获得的AppID，输入项目名称，在下面选择建立“普通快速启动模板”，建议勾选该项，这样会帮你自动建立小程序开发的目录结构。 开发者工具简介 在工具上方是工具栏，主体部分由四个部分组成，左边是小程序的预览图，可以在上方选择模拟器的手机型号和显示比例等，中间是小程序的代码目录，右边是代码编辑区，下方是控制台。在工具台可以选择编译模式，一般就使用“普通编译”；上方有【编译】按钮，但实际上Ctrl（Command）+ S保存代码的时候会自动进行编译；【预览】和【真机调试】都需要微信扫码，需要注意的是，只有将用户添加到项目成员并给予开发者权限才能够使用该功能。 小程序代码构成在目录里面，可以看到项目自动生成了一些目录和文件。其中，有四种不同类型的文件： .json后缀的JSON文件 .wxml后缀的WXML模板文件 .wxss后缀的WXSS样式文件 .js后缀的JS脚本逻辑文件 JSON文件json文件一共有三种，app.json是小程序的全局配置，包括页面路径、界面表现、导航栏设置、网络超时时间等，分为pages（页面）字段和windows（页面顶部）字段。需要注意的是：页面路径里面，系统默认排在第一个的页面是小程序的初始页面。 project.config.json保存的主要是用户的个性化配置，比如界面颜色、编译配置，当重新安装工具或者换电脑时，只要载入之前的文件，开发者工具就会自动恢复之前的个性化配置。 page.json文件。在每一个页面目录下都有一个json文件，和app.json的区别在于，其中只能使用windows字段的内容。app.json负责对全局进行配置，而page.json对每一个页面的属性进行独立的配置。局部json的配置会自动覆盖全局json的配置。 WXML文件写过前端的人知道，在网页编程里面使用的主要是HTML+CSS+JavaScript，小程序里面也大致是这样，WXML负责描述页面的结构和内容，WXSS用户描述页面的样式，JS则用来处理页面和用户的交互。 WXML和HTML十分相似，都是由标签和属性组成，但是标签使用上有一些区别，针对小程序的特点，将很多组件包装了起来，以标签的形式提供给开发者使用，比如地图、弹窗等。同时，WXML还有wx:if这样的属性用来控制内容显示，&amp;#123&amp;#123&amp;#125&amp;#125表达式用于将渲染和逻辑分离，在WXML里面使用变量名，在JS里面使用this.setData函数来修改变量内容，并实时渲染到页面上。 WXSS具有大部分CSS的特性，需要注意的是其新增加了一个尺寸单位。为了对不同的手机设备继续适配，WXSS采用了rpx单位，其值等于用户手机设备的宽/750，即默认所有的屏幕宽度都是750rpx，在渲染时，由小程序底层自动计算实际的大小。但是换算采用的是浮点数运算，所以可能有一些误差。此外，小程序开发中，一些组件需要在js里面进行样式制作，也就无法使用rpx单位，需要自行处理，此部分在后续的文章里面会进行描述。 JS文件JS的语法就没什么好说的，在page.js文件里面会默认有一个data内容，在里面定义的对象可以通过&amp;#123&amp;#123&amp;#125&amp;#125的形式在WXML文件里面使用，并通过this.setData进行修改，以达到逻辑层和渲染层分离和实时渲染的目的。 协作开发 版本管理初始化我自己在开发过程中主要通过Git+码云来实现代码的版本控制，在这里仅简单介绍一下。首先需要在码云里面注册一个账号，随后创建一个项目。在微信开发者工具里面找到工具栏的【版本管理】，单击进行后会提示初始化Git仓库，点击确认即可，这一步相当于执行 git int命令。 配置仓库信息初始化完成后，就可以看到本地的仓库和当前Git状态。然后在【工作空间】里面点击进入【设置】页面，【通用】里面选择编辑用户信息，填写码云的邮箱账号和自己的用户名，在进入【远程】选项卡，添加远程仓库，填写名称（自定）和仓库链接即可。 点击【网络和认证】选项卡里面选择认证方式为“使用用户名和密码”，输入码云的账号和密码，到此配置就已经完成。 修改和提交代码修改代码之后，进入【版本控制】页面，在【工作区】可以看到被修改的文件，在下方填写标题，并提交，就可以将代码提交到本地分支里面。点击上方的【推送】，填写分支信息，点击确定就可以将代码提交到远程仓库。之后可以使用【抓取】和【拉取】功能，从远程仓库里面合并其他人的代码。 小结此部分主要是对小程序开发前的准备工作、开发工具、代码结构进行了简单的介绍，后面的部分就主要是一些具体的功能代码，会比较零散，以后当做开发字典使用。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java synchronized详解]]></title>
    <url>%2F2018%2F11%2F12%2Fsynchronized%2F</url>
    <content type="text"><![CDATA[synchronized 是Java语言的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码。 当两个并发线程访问同一个对象 object 中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 然而，当一个线程访问 object 的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该 object 中的非 synchronized(this) 同步代码块。 尤其关键的是，当一个线程访问 object 的一个 synchronized(this) 同步代码块时，其他线程对 object 中所有其它 synchronized(this) 同步代码块的访问将被阻塞。 第三个例子同样适用其它同步代码块。也就是说，当一个线程访问 object 的一个 synchronized(this) 同步代码块时，它就获得了这个 object 的对象锁。结果，其它线程对该 object 对象所有同步代码部分的访问都被暂时阻塞。 以上规则对其它对象锁同样适用. ##举例说明.当两个并发线程访问同一个对象 object 中的这个synchronized(this)同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。 123456789101112131415161718package ths;public class Thread1 implements Runnable &#123; public void run() &#123; synchronized(this) &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(Thread.currentThread().getName() + " synchronized loop " + i); &#125; &#125; &#125; public static void main(String[] args) &#123; Thread1 t1 = new Thread1(); Thread ta = new Thread(t1, "A"); Thread tb = new Thread(t1, "B"); ta.start(); tb.start(); &#125;&#125; 输出结果： 12345678910A synchronized loop 0 A synchronized loop 1 A synchronized loop 2 A synchronized loop 3 A synchronized loop 4 B synchronized loop 0 B synchronized loop 1 B synchronized loop 2 B synchronized loop 3 B synchronized loop 4 2.当一个线程访问object的一个synchronized(this)同步代码块时，另一个线程仍然可以访问该object中的非synchronized(this)同步代码块。 1234567891011121314151617181920212223242526272829303132package ths;public class Thread2 &#123; public void m4t1() &#123; synchronized(this) &#123; int i = 5; while( i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : " + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; &#125; public void m4t2() &#123; int i = 5; while( i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : " + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; public static void main(String[] args) &#123; final Thread2 myt2 = new Thread2(); Thread t1 = new Thread( new Runnable() &#123; public void run() &#123; myt2.m4t1(); &#125; &#125;, "t1" ); Thread t2 = new Thread( new Runnable() &#123; public void run() &#123; myt2.m4t2(); &#125; &#125;, "t2" ); t1.start(); t2.start(); &#125; &#125; 输出结果：12345678910t1 : 4 t2 : 4 t1 : 3 t2 : 3 t1 : 2 t2 : 2 t1 : 1 t2 : 1 t1 : 0 t2 : 0 3.尤其关键的是，当一个线程访问object的一个synchronized(this)同步代码块时，其他线程对object中所有其它synchronized(this)同步代码块的访问将被阻塞。 1234567891011121314//修改Thread2.m4t2()方法：public void m4t2() &#123; synchronized(this) &#123; int i = 5; while( i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : " + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125;&#125; 输出结果： 12345678910t1 : 4 t1 : 3 t1 : 2 t1 : 1 t1 : 0 t2 : 4 t2 : 3 t2 : 2 t2 : 1 t2 : 0 4.第三个例子同样适用其它同步代码块。也就是说，当一个线程访问object的一个synchronized(this)同步代码块时，它就获得了这个object的对象锁。结果，其它线程对该object对象所有同步代码部分的访问都被暂时阻塞。 123456789101112//修改Thread2.m4t2()方法如下：public synchronized void m4t2() &#123; int i = 5; while( i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : " + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; 输出结果：12345678910t1 : 4 t1 : 3 t1 : 2 t1 : 1 t1 : 0 t2 : 4 t2 : 3 t2 : 2 t2 : 1 t2 : 0 5.以上规则对其它对象锁同样适用:1234567891011121314151617181920212223242526272829303132333435363738394041package ths;public class Thread3 &#123; class Inner &#123; private void m4t1() &#123; int i = 5; while(i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : Inner.m4t1()=" + i); try &#123; Thread.sleep(500); &#125; catch(InterruptedException ie) &#123; &#125; &#125; &#125; private void m4t2() &#123; int i = 5; while(i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : Inner.m4t2()=" + i); try &#123; Thread.sleep(500); &#125; catch(InterruptedException ie) &#123; &#125; &#125; &#125; &#125; private void m4t1(Inner inner) &#123; synchronized(inner) &#123; //使用对象锁 inner.m4t1(); &#125; private void m4t2(Inner inner) &#123; inner.m4t2(); &#125; public static void main(String[] args) &#123; final Thread3 myt3 = new Thread3(); final Inner inner = myt3.new Inner(); Thread t1 = new Thread( new Runnable() &#123;public void run() &#123; myt3.m4t1(inner);&#125; &#125;, "t1"); Thread t2 = new Thread( new Runnable() &#123;public void run() &#123; myt3.m4t2(inner);&#125; &#125;, "t2"); t1.start(); t2.start(); &#125; &#125; 输出结果： 尽管线程t1获得了对Inner的对象锁，但由于线程t2访问的是同一个Inner中的非同步部分。所以两个线程互不干扰。 12345678910t1 : Inner.m4t1()=4 t2 : Inner.m4t2()=4 t1 : Inner.m4t1()=3 t2 : Inner.m4t2()=3 t1 : Inner.m4t1()=2 t2 : Inner.m4t2()=2 t1 : Inner.m4t1()=1 t2 : Inner.m4t2()=1 t1 : Inner.m4t1()=0 t2 : Inner.m4t2()=0 现在在Inner.m4t2()前面加上synchronized：12345678910private synchronized void m4t2() &#123; int i = 5; while(i-- &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + " : Inner.m4t2()=" + i); try &#123; Thread.sleep(500); &#125; catch(InterruptedException ie) &#123; &#125; &#125; &#125; 输出结果： 尽管线程t1与t2访问了同一个Inner对象中两个毫不相关的部分,但因为t1先获得了对Inner的对象锁，所以t2对Inner.m4t2()的访问也被阻塞，因为m4t2()是Inner中的一个同步方法。 12345678910t1 : Inner.m4t1()=4 t1 : Inner.m4t1()=3 t1 : Inner.m4t1()=2 t1 : Inner.m4t1()=1 t1 : Inner.m4t1()=0 t2 : Inner.m4t2()=4 t2 : Inner.m4t2()=3 t2 : Inner.m4t2()=2 t2 : Inner.m4t2()=1 t2 : Inner.m4t2()=0]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>synchronized</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[念念不忘，必有回响]]></title>
    <url>%2F2018%2F09%2F30%2F%E5%BF%B5%E5%BF%B5%E4%B8%8D%E5%BF%98%2F</url>
    <content type="text"><![CDATA[梦一样的九月转眼就结束了，现在想想还是觉得有些不可思议，月初的时候还过着早八晚十的图书馆考研生活，现在却躺在家里的床上无聊地写着博客。六号的时候在空间转发了那只白色的可爱小狐狸，开玩笑一般地让珞珈山神兽“保佑我九月诸事顺心”，没想到真的是好运不断。 皆有所得保研 转发完小狐狸的当天下午就得知我们班有6个保研名额，我恰好排名第8，又听说排在前面的两名同学大概率会出国，没过两天这一点也确定了，于是就这样获得了推免资格。 双学位毕设 在暑假准备考研的时候，想着自己需要专心复习（当然这也可能是给自己偷懒找的借口），就很早跟论文指导老师说自己放弃毕设。本来以为这件事注定会成为我大学生活的一大遗憾，但当保研确定之后，又突然想完成这个毕设。当时应该是9号前后，按照通知上的要求，17号查重，18号答辩，我还有一周多一点的时间。再次联系指导老师，很幸运老师表示了支持和鼓励，告诉我可以尽快选一个自己熟悉的方向完成初稿，答辩完之后还有10天可以修改。于是半天构思，三天半写代码，三天写论文，还留了一天完善和改重。提交之前自己查怎么也没低于10%的论文，老师发给我的报告显示是1.7%，随后答辩也得到了老师“总体结构内容不错，存在一些小问题”的评价。 成绩 上学期双学位的考试一直还有两门成绩没有出来，恰好又是我比较担心的科目：系统结构和算法设计。尤其是系统结构，基本靠考前突击。记得考试的时候，老师还问同学复习了多久，一个说一周，一个说两周，还好没问我，不然说两天多尴尬。在做毕设的时候，突然在群里看到有人说成绩出来了，赶紧登上系统，长舒一口气：80，95。 专业 获得保研资格的时候已经是九月中旬了，由于之前一直在准备考研，没有参加什么夏令营或者保研面试，就放弃了去其他学校的念头，把目标转向了本院新开的数据科学专业。但是有个问题是，这个专业理论上只招理工科背景的学生。后来去找徐老师咨询志愿的时候，提到了我修过华科计算机的事情，她说到时候会给学院反馈一下。到填报志愿的那天，早上估摸着快上班了，再次给她发短信表明了自己的兴趣和意愿，终于在快中午的时候收到了待录取通知。 奖学金 九月份由于各种事情交错在一起，奖学金方面就抱着比较随意的心态申报了，材料也没花什么心思准备。班级初审的时候总评第3，后来学院审核变成了第5，从乙等变成了丙等，但是自己就很佛系，完全没啥感觉。刚才晚上看到通知，获得了国励，也算是很不错的结果了。 过程不易 看起来一切都是很顺利，但是过程还是只有自己知道。 整个九月份精神状态和睡眠状态就很不好，半夜经常惊醒，早上一般到了6点就再也睡不着；做毕设期间为了省时间改变了睡午觉的习惯，等到答辩结束后想睡个午觉，躺下没多久就会醒过来，总觉得有什么事情没做完；噩梦也是常有，印象最深的有两次，第一次梦到自己的电脑进水不能用了，开始好像觉得问题不大，在算自己能攒出多少钱买新的，突然想到自己的源代码和论文都在电脑里面，马上就被吓醒了，第二次则是梦到自己填的志愿没被录取；经常写代码写到头疼，有天晚上修仙突然开始流鼻血，还以为自己要猝死了…… 未来可期 写了这么多，并不是想秀自己的好运，也不是抱怨自己有多累。18号结束答辩看了电影《风语咒》，晚上在学校散步的时候，满脑子都是八个字“念念不忘，必有回响”，这就是我想表达的。没有什么是可以轻易获得的，背后必然有巨大的努力。我也很庆幸，自己的付出没有白费，虽然和身边优秀的同学相比还差得很远，但总算是有所收获，大学生活没有虚度。很感谢这段时间亲人、老师、朋友对我的关心和支持，感谢那只不幸离世的小狐狸，也希望各位同学的努力都会有结果，都能收获自己想要的。 在论文致谢的最后一段，写的是“希望这篇论文不是我计算机学习的结束，而是一个新的开始”，现在我应该就站在这个起点上，未来可期，继续加油！]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最怕学霸秀恩爱]]></title>
    <url>%2F2018%2F06%2F15%2F%E6%9C%80%E6%80%95%E5%AD%A6%E9%9C%B8%E7%A7%80%E6%81%A9%E7%88%B1%2F</url>
    <content type="text"><![CDATA[俗话说，在学校最难受的三件事是： 看学霸秀成绩 看情侣秀恩爱 看土豪炫富 比这更难受的三件事是： 看学霸秀恩爱 看土豪秀成绩 看情侣炫富 今天就被一对学霸秀了一脸，在此先记下这个仇了…… PS:这张图是某人自己P的，摄影来自对面的我 没错就是这两个人，两个不折不扣的学霸，分别保研了北大和武大，成绩好，颜值高，气质佳，能力强，极具音乐天赋，刚才还跟我说自小担任文艺委员，小学钢琴考了8级，emmm。 在大一上党课的时候认识了姐夫，被他“骗”进联席会后又认识了羽茜姐姐，后来才知道他们两的关系，还知道了他们也是在联席会认识的……虽然作为单身狗，经常被他们两秀一脸，但还是很感谢他们这两年来对我的帮助，不光是联席会材料和党课的工作，还有学习和生活，一直以来都把他们当作学习的榜样。教我理清复杂的入党材料，带我做好党课班长，用”专业课90+一点也不难“、”不拿国奖不带我玩“来激励我学习，晚上请我吃饭还因为吃辣把嗓子吃坏了…… 临近毕业，别无所赠，只有祝福了，希望你们学业顺利，幸福美满，一直恩爱下去。（记得以后带我去北大玩）]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>大学</tag>
        <tag>生活</tag>
        <tag>记仇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 41 缺失的第一个正数]]></title>
    <url>%2F2018%2F06%2F15%2FLeetCode%2041%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例1： 输入：[1,2,0] 输出：3 示例2： 输入：[3,4,-1,1] 输出：2 示例3： 输入：[7,8,9,11,12] 输出：1 说明： 你的算法的时间复杂度应为 O(n)，并且只能使用常数级别的空间。 解题思路假设给定数组的长度是 n ，可分为两种情况进行讨论。 如果数组是从 1开始连续的正整数序列，那么数组的最大值就是n，第一个未出现的正整数就是 n+1 ； 如果数组并非从 1 开始连续的正整数序列，第一个未出现的正整数必然大于0，且小于等于 n 。 针对第二种情况，我们借助桶排序（bucket sort）的思路来对数组进行调整，使其中的部分元素满足第一种情况。 桶排序基本思想 假设待排序的数组A中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组R，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个”桶”。 在排序时，逐个遍历数组A，将数组A的值，作为”桶数组R”的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组A[3]=5，则将R[5]的值+1。 对数组进行遍历，如果某个元素在 1~n 之间，就将其放到原数组中的i-1位置。再次对数组进行遍历，找出第一个不满足 nums[i] != i+1 的数，i+1就是要找的第一个未出现的正整数。 代码实现12345678910111213141516171819public int firstMissingPositive(int[] nums) &#123; int max = nums.length ; if(max == 0) &#123; return 1 ; &#125; for(int i = 0 ; i &lt; max ; i++) &#123; while(nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= max &amp;&amp; nums[nums[i]-1] != nums[i]) &#123; int temp = nums[i] ; nums[i] = nums[temp - 1] ; nums[temp - 1] = temp ; &#125; &#125; for(int i = 0 ; i &lt; max ; i++) &#123; if(nums[i] != i + 1) &#123; return i + 1 ; &#125; &#125; return max + 1 ;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>最小正整数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题]]></title>
    <url>%2F2018%2F06%2F15%2FnQueen%2F</url>
    <content type="text"><![CDATA[算法问题描述 八皇后问题是一个以国际象棋为背景的问题：如何能够在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后？为了达到此目的，任两个皇后都不能处于同一条横行、纵行或斜线上。八皇后问题可以推广为更一般的n皇后摆放问题：这时棋盘的大小变为n×n，而皇后个数也变成n。当且仅当n = 1或n ≥ 4时问题有解. 转换成算法问题可以表述为： 在一个N*N的棋盘上，一共需要放置N枚棋子 要求每一行，每一列上只能放置1枚棋子 要求任意斜线上也只能有1枚棋子 回溯算法的主要思想 回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。 但当探索到某一步时，发现原先选择并不优或达不到目标， 就退回一步重新选择，这种走不通就退回再走的技术为回溯法， 而满足回溯条件的某个状态的点称为“回溯点”。 主要思想： 按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。 回溯算法解N皇后算法描述 这里用一个N*N的矩阵来存储棋盘。注意，此处的N应该大于等于4，2皇后问题和3皇后问题均无解。 算法开始，清空棋盘。当前行设为第1行，当前列设为第1列。 判断当前行，当前列的位置是否可以放置皇后，即该位置所在的行、列和斜线上是否已经有其他皇后存在。 如果符合放置条件，在当前位置放置1个皇后，当前行设为下一行，当前列设为第一列；如果不符合放置条件，当前列设为下一列，重复第2步。 如果某一行遍历结束后（当前列等于），没有到符合条件的位置放置皇后，那么进行回溯：当前行设为上一行，当前列设为上一行皇后所在位置的下一列，取走该行的皇后。注意，如果回溯到了第1行，算法结束。 如果最后一行找到了皇后位置，就代表有一个问题的可行解，将其输出。然后，当前列设为下一列，取走这一行的皇后，继续执行算法。 代码描述（Java） 实现该算法时，面临的第一个问题就是如何判断当前位置(x,y)是否可以放置皇后。最容易想到的方法是将棋盘存为一个二维矩阵，然后判断X行和Y列上是否已有皇后存在，再判断同一斜线上是否存在其他皇后。用该方法可以实现，代码也不复杂，但效率比较低下。N皇后问题中，需要多次调用这个方法，因此，在设计算法的过程中，要尽可能的对其进行优化。 在这里介绍另外一种方法:把棋盘存储为一个N维数组a[N]，数组中第i个元素的值代表第i行的皇后位置，这样便可以把问题的空间规模压缩为一维O(N)，在判断是否冲突时也很简单，首先每行只有一个皇后，且在数组中只占据一个元素的位置，行冲突就不存在了，其次是列冲突，判断一下是否有a[i]与当前要放置皇后的列j相等即可。通过观察可以发现所有在斜线上冲突的皇后的位置都有规律，即它们所在的行列互减的绝对值相等，即| row – i | = | col – a[i] | 。这样当前位置是否可以放置皇后的问题已经解决。 接下来，将算法分成若干个过程，一步步进行代码实现。 对棋盘进行初始化12345private static void init(int a[])&#123; for (int i = 0 ; i &lt; a.length ; i++) &#123; a[i] = INITIAL ; &#125;&#125; 对一维数组进行遍历，将所有位置都置为同一个初始值。 判断当前位是否可以放置皇后123456789private static boolean valid(int a[],int row,int col) &#123; for(int i = 0 ; i &lt; a.length ; i++) &#123; //列是否相等，行列差是否相等 if (col == a[i] || Math.abs(row - i) == Math.abs(col - a[i])) &#123; return false ; &#125; &#125; return true ;&#125; 只需要判断列冲突和斜线冲突的情况，注意斜线判断的时候是对绝对值的比较。 存储一个可行解123456private static void printqueen(int a[]) &#123; for(int i:a) &#123; System.out.print(i+1+" "); &#125; System.out.println();&#125; 简单的数组打印，不需要多说。加1是为了个人习惯，阅读比较方便。 寻找可行解的过程12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static int queen(int i) &#123; if(i &lt; 4 || i &gt; 64) &#123; return 0 ; &#125; int a[] = new int[i] ; init(a) ; //初始化 int x = 0 ; //行 int y = 0 ; //列 while(x &lt; i) &#123; //遍历该行所有列，找出皇后的位置 while(y &lt; i) &#123; if(valid(a,x,y)) &#123; a[x] = y ; y = 0 ; break ; &#125; else&#123; y++ ; &#125; &#125; //如果该行未找到皇后位置 if(a[x] == INITIAL) &#123; //如果已经回溯到了第一行，结束算法 if(x == 0) &#123; break ; &#125; else &#123; x-- ; y = a[x] + 1 ; a[x] = INITIAL ; continue ; &#125; &#125; //如果最后一行找到了皇后，代表一个解 if(x == i - 1) &#123; //输出解 printqueen(a); cout++ ; y = a[x] + 1 ; a[x] = INITIAL ; continue ; &#125; x++ ; &#125; return cout ; //返回可行解个数&#125; 入口参数i代表求解皇后问题，应该不小3。返回值是问题的可行解个数。 首先，对数组进行初始化，定义两个变量X和Y，分别代表行和列。第1个while是对行的遍历，第2个while是寻找当前行皇后的位置。如果当前行没找到，进行回溯，如果当前行是最后一行，输出一个解。当回溯到第一行时，算法结束，返回可行解个数。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import java.lang.Math ;public class NQueen &#123; private static final int INITIAL = -10000 ; private static int cout = 0 ; //对棋盘进行初始化 private static void init(int a[])&#123; for (int i = 0 ; i &lt; a.length ; i++) &#123; a[i] = INITIAL ; &#125; &#125; //判断当前位置是否可以放置一个皇后 private static boolean valid(int a[],int row,int col) &#123; for(int i = 0 ; i &lt; a.length ; i++) &#123; //列是否相等，行列差是否相等 if (col == a[i] || Math.abs(row - i) == Math.abs(col - a[i])) &#123; return false ; &#125; &#125; return true ; &#125; //存储一个可行解 private static void printqueen(int a[]) &#123; for(int i:a) &#123; System.out.print(i+1+" "); &#125; System.out.println(); &#125; public static int queen(int i) &#123; if(i &lt; 4 || i &gt; 64) &#123; return 0 ; &#125; int a[] = new int[i] ; init(a) ; //初始化 int x = 0 ; //行 int y = 0 ; //列 while(x &lt; i) &#123; //遍历该行所有列，找出皇后的位置 while(y &lt; i) &#123; if(valid(a,x,y)) &#123; a[x] = y ; y = 0 ; break ; &#125; else&#123; y++ ; &#125; &#125; //如果该行未找到皇后位置 if(a[x] == INITIAL) &#123; //如果已经回溯到了第一行，结束算法 if(x == 0) &#123; break ; &#125; else &#123; x-- ; y = a[x] + 1 ; a[x] = INITIAL ; continue ; &#125; &#125; //如果最后一行找到了皇后，代表一个解 if(x == i - 1) &#123; //输出解 printqueen(a); cout++ ; y = a[x] + 1 ; a[x] = INITIAL ; continue ; &#125; x++ ; &#125; return cout ; //返回可行解个数 &#125; public static void main(String args[]) &#123; long startTime=System.currentTimeMillis(); //获取开始时间 System.out.println(queen(8)+"个解"); long endTime=System.currentTimeMillis(); //获取结束时间 System.out.println("程序运行时间： "+(endTime-startTime)+"ms"); &#125;&#125; 输出结果：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293941 5 8 6 3 7 2 4 1 6 8 3 7 4 2 5 1 7 4 6 8 2 5 3 1 7 5 8 2 4 6 3 2 4 6 8 3 1 7 5 2 5 7 1 3 8 6 4 2 5 7 4 1 8 6 3 2 6 1 7 4 8 3 5 2 6 8 3 1 4 7 5 2 7 3 6 8 5 1 4 2 7 5 8 1 4 6 3 2 8 6 1 3 5 7 4 3 1 7 5 8 2 4 6 3 5 2 8 1 7 4 6 3 5 2 8 6 4 7 1 3 5 7 1 4 2 8 6 3 5 8 4 1 7 2 6 3 6 2 5 8 1 7 4 3 6 2 7 1 4 8 5 3 6 2 7 5 1 8 4 3 6 4 1 8 5 7 2 3 6 4 2 8 5 7 1 3 6 8 1 4 7 5 2 3 6 8 1 5 7 2 4 3 6 8 2 4 1 7 5 3 7 2 8 5 1 4 6 3 7 2 8 6 4 1 5 3 8 4 7 1 6 2 5 4 1 5 8 2 7 3 6 4 1 5 8 6 3 7 2 4 2 5 8 6 1 3 7 4 2 7 3 6 8 1 5 4 2 7 3 6 8 5 1 4 2 7 5 1 8 6 3 4 2 8 5 7 1 3 6 4 2 8 6 1 3 5 7 4 6 1 5 2 8 3 7 4 6 8 2 7 1 3 5 4 6 8 3 1 7 5 2 4 7 1 8 5 2 6 3 4 7 3 8 2 5 1 6 4 7 5 2 6 1 3 8 4 7 5 3 1 6 8 2 4 8 1 3 6 2 7 5 4 8 1 5 7 2 6 3 4 8 5 3 1 7 2 6 5 1 4 6 8 2 7 3 5 1 8 4 2 7 3 6 5 1 8 6 3 7 2 4 5 2 4 6 8 3 1 7 5 2 4 7 3 8 6 1 5 2 6 1 7 4 8 3 5 2 8 1 4 7 3 6 5 3 1 6 8 2 4 7 5 3 1 7 2 8 6 4 5 3 8 4 7 1 6 2 5 7 1 3 8 6 4 2 5 7 1 4 2 8 6 3 5 7 2 4 8 1 3 6 5 7 2 6 3 1 4 8 5 7 2 6 3 1 8 4 5 7 4 1 3 8 6 2 5 8 4 1 3 6 2 7 5 8 4 1 7 2 6 3 6 1 5 2 8 3 7 4 6 2 7 1 3 5 8 4 6 2 7 1 4 8 5 3 6 3 1 7 5 8 2 4 6 3 1 8 4 2 7 5 6 3 1 8 5 2 4 7 6 3 5 7 1 4 2 8 6 3 5 8 1 4 2 7 6 3 7 2 4 8 1 5 6 3 7 2 8 5 1 4 6 3 7 4 1 8 2 5 6 4 1 5 8 2 7 3 6 4 2 8 5 7 1 3 6 4 7 1 3 5 2 8 6 4 7 1 8 2 5 3 6 8 2 4 1 7 5 3 7 1 3 8 6 4 2 5 7 2 4 1 8 5 3 6 7 2 6 3 1 4 8 5 7 3 1 6 8 5 2 4 7 3 8 2 5 1 6 4 7 4 2 5 8 1 3 6 7 4 2 8 6 1 3 5 7 5 3 1 6 8 2 4 8 2 4 1 7 5 3 6 8 2 5 3 1 7 4 6 8 3 1 6 2 5 7 4 8 4 1 3 6 2 7 5 92个解程序运行时间： 11ms 递归实现 回溯算法通常可以用递归来实现，其主要代码如下：12345678910111213private void backtrack(int x) &#123; if(x == n)&#123; //如果找到一个解，进行输出 cout++ ; printqueen() ; &#125; else for(int y = 0 ;y &lt; n;y++)&#123; //探测当前行的每一列 a[x] = y ; if(valid(a,x,y)) &#123; backtrack(x+1) ; //递归调用，循环求解 &#125; &#125; &#125; 该方法由于在探测第x行后，如果找到一个可以放置皇后的位置y后，则会递归探测下一行，结束后则会继续探测x行y+1列，故可以找到所有的N皇后的解。 但是一般来说递归的效率比较差，因此此处仅做简单介绍，有兴趣的朋友可自行实现。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯</tag>
        <tag>N皇后</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯法应用举例——子数组积/和问题]]></title>
    <url>%2F2018%2F06%2F15%2F%E5%9B%9E%E6%BA%AF%E6%B3%95%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B%E2%80%94%E2%80%94%E5%AD%90%E6%95%B0%E7%BB%84%E7%A7%AF%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[leetcode 713 在 leetcode上面有这样一道题： 给定一个正整数数组 nums。 找出该数组内乘积小于 k 的连续的子数组的个数。 示例1： 输入: nums = [10,5,2,6], k = 100输出: 8解释: 8个乘积小于100的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。需要注意的是 [10,5,2] 并不是乘积小于100的子数组。 该问题的解题思路就是通过对数组的遍历，找出其中连续积小于 k 的区间，每增加一个元素，就说明有该区间的大小的子数组满足条件，若积大于或等于k，则将区间左边的元素去掉，继续执行。其代码如下： 123456789101112public int numSubarrayProductLessThanK(int[] nums, int k) &#123; int cout = 0 ; int left = 0 ; int total = 1 ; for(int right = 0 ; right &lt; nums.length ; right++) &#123; total *= nums[right] ; while(total &gt;= k &amp;&amp; left &lt;= right ) total /= nums[left++] ; cout += right - left + 1 ; &#125; return cout ;&#125; 但是这道题不是今天的主角，做完这道题之后，突然想到，如果子数组是非连续的应该如何求解呢？ 子数组积问题 现在将问题修改为： 给定一个正整数数组 nums。 找出该数组内乘积小于 k 的任意子数组的个数。 解决该问题的主要思路还是和之前的N皇后问题一样，使用回溯算法。 首先定义出问题的单个解。我们可以使用一个一维数组 status[] 来表示单个的解，数组长度和 nums 相同， status[i] 即对应 nums[i] 的状态。在一个解中，单个元素有两种状态，及在解中或者不在解中，因此可以用1和0来表示。 然后我们可以定义问题的解空间。如图所示，用状态空间树来表示解空间就是一棵二叉树，在初始状态下，面临第一次选择，即 statu[0]应该取1还是0，依次类推，从根节点到叶子节点的一条路径就表示问题的一个解。 寻找可行解的过程就是遍历树的过程。在此过程中，我们需要利用一个限界函数，用来剪除掉那些不可能产生可行解的分支。根据题意，我们可以将限界函数定义为：已有元素的积小于 k（也可进一步限定解，剩余的元素必须可以生成可行解，即剩余元素和已有元素的积要大于等于 k ）。 按照深度优先的策略遍历状态空间树，就是回溯的思想，而采用宽度优先的策略则是另一种算法“分支-限界”。 对问题进行分析之后，进行代码实现，在N皇后问题中，使用的是迭代，而此次使用递归来对问题进行求解。 123456789101112131415161718public int backtrack(int[] nums , int status[] , int x , int k ) &#123; status[x] = 1 ; //生成左子树 int total = 1 ; int cout = 0 ; for(int i = 0 ; i &lt;= x ; i++) &#123; if(status[i] != 0) total *= nums[i] ; &#125; if(total &lt; k ) &#123; //是否满足限界函数 cout++ ; if(x &lt; nums.length - 1) cout += backtrack(nums , status , x+1 , k) ; &#125; if(x &lt; nums.length - 1) status[x] = 0 ; //生成右子树 cout += backtrack(nums , status , x+1 , k) ; return cout ;&#125; nums 是给定的数组， status 用来保存每个元素的状态（0或1）， x 用来记录当前结点， k 是给定的积最大值。函数返回一个 cout ，也就是当前子树的可行解个数。 首先令当前结点状态为1，生成左子树，计算已有元素的积，判断是否小于 k ，如果小于则将 cout 加1，对下一个结点进行递归调用，如果不满足则该分支结束遍历。然后令当前结点状态为0，生成右子树，进行递归调用。最后返回 cout 值。 下面是数组初始化和首次调用： 1234567public int numSubarrayProductLessThanK(int[] nums, int k) &#123; int status[] = new int[nums.length] ; for(int i = 0 ; i &lt; status.length ; i++) status[i] = 0 ; int x = 0 ; return backtrack(nums,status,x,k) ;&#125; 子数组和问题 子数组和问题和上面问题相似，要求是找出数组内和等于 k 的任意子数组个数，只需要修改限界函数就可以得到解。 实现代码如下： 123456789101112131415161718192021222324252627public int NumSubarrayProductIsK(int nums[] , int k) &#123; int status[] = new int[nums.length] ; for(int i = 0 ; i &lt; status.length ; i++) &#123; status[i] = 0 ; &#125; int x = 0 ; return backttack_2(nums, status, x, k) ;&#125;public int backttack_2(int nums[] , int statu[] , int x , int k ) &#123; statu[x] = 1 ; //生成左子树 int cout = 0 ; int total = 0 ; for(int i = 0 ; i &lt;= x ; i++) &#123; total += nums[i]*statu[i] ; &#125; if(total == k) &#123; //判断是否满足限界函数 cout++ ; &#125; else if(total &lt; k &amp;&amp; x &lt; nums.length-1) &#123; cout += backttack_2(nums, statu, x+1, k) ; &#125; if(x &lt; nums.length - 1) &#123; statu[x] = 0 ; //生成右子树 cout += backttack_2(nums, statu, x+1, k) ; &#125; return cout ;&#125; 测试代码和输出结果如下： 12345678public class Test &#123; public static void main(String[] args) &#123; Solution s = new Solution() ; int nums[] = new int[]&#123;5,10,6,4,5&#125; ; System.out.println("有"+s.NumSubarrayProductIsK(nums, 10)+"个数组和等于10"); System.out.println("有"+s.numSubarrayProductLessThanK(nums, 10)+"个子数组积小于10"); &#125;&#125; 有3个数组和等于10 有4个子数组积小于10]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯</tag>
        <tag>子数组和</tag>
        <tag>子数组积</tag>
      </tags>
  </entry>
</search>
